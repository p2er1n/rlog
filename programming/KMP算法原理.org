#+title: KMP算法原理
#+author: Peerin
#+date: <Fri Sep 29 17:37:48 2023>

* 原理

kmp算法的关键在与next数组，如何求得next数组，为什么这么求，为什么这么用next数组？

kmp算法的重要点在于它在模式串不匹配的时候不需要重新回退主串，只需要根据next数组调整模式串的起始匹配，接着匹配即可。

想一想这样一个主串：abcdeabc

以及这一个模式串：abce

一般算法是这样做的：

1. 主串索引0,模式串索引0

2. 同时逐个移动主串和模式串索引

3. 主串索引为3,模式串索引为3,'d' != 'e'，匹配失败

4. 回退主串索引到1,重置模式串索引为0, 执行2

5. 不断执行以上步骤


注意到第四步，有必要吗？当模式串索引重置到0的时候，

abcdeabc
 ^
abce
^

'b' != 'a' 然后又重置模式串索引，主串索引加1，

我们能否提前得知这种情况，然后排除这种情况，因为我们已经在第一次匹配成功了一部分abc,abce的首字母为a,和首字母为非a的匹配肯定不可能成功。

对了！

因此，我们可以记录这样一个next数组，他的作用是指示下一次尝试匹配从模式串的哪里开始，

比如上面的例子，主串为abcdeabc，那么模式串匹配失败，但是我们已经取得了“部分成功”，即abc是匹配的，利用这个消息我们就避免了a再和b和c的比较了。

因为这样的比较肯定是无效的：

abcdeabc
 ^
 abce 
 ^
 
abcdeabc
  ^
  abce 
  ^

我们可以直接让a和主串的d比较，这个比较是无法避免的，因为我们不知道主串下一个字符是什么，可能后面就是一个abce呢！

因此我们这样定义next数组：next[i] 表面模式串的位置为i的字符和主串的相应字符匹配失败后，下一个和主串当前位置匹配的模式串的字符的位置。

我们需要跳过尽可能多的“部分匹配”部分，需要注意，当我们制定模式串从某一个位置开始和主串匹配的时候，我们需要保证模式串这一位置之前的部分和

主串当前匹配位置之前相等长度的字符串是相同的，否则匹配就是失败的了。

举例子，abcabab和子串（就是模式串）abcabb

abcabab
   **^
abcabb
**^

画星号的部分必须相同，也就是部分匹配字符串的某个长度的前缀和后缀相同，那么我们就可以跳过模式串这个前缀或后缀的长度个字符，为了跳过最多的字符，我们

要找部分匹配字符串的最大相同前后缀的长度。

因此abcabb的next数组为0,0,0,1,2,0。

有一个地方需要注意，如果从主串某个字符开始匹配时，第一个字符双方就不相同，那么按照next数组，模式串还是会从第一个字符开始，主串索引不变的话就会不断重复，死循环。

因此我们要求，如果模式串根据next数组回退到第一个字符的时候，和主串不匹配，主串索引加1。也就是回退到一般算法。

* 代码

** cpp

#+begin_src cpp
  int kmp(string &s, string &ss){
    //假设next数组已知
    for(int i = 0, j = 0;i < s.length() && j < ss.length();){
      if(s[i] != ss[j]){
	j = next[j];
	if(j == 0 && s[i] != ss[j]) i++;
      }else{
	if(j == ss.length()-1) return i-j;
	i++;
	j++;
      }
    }
    return -1;
  }
#+end_src

