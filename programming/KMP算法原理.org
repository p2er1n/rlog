#+title: KMP算法原理
#+author: Peerin
#+date: <Fri Sep 29 17:37:48 2023>

* 原理

kmp算法的关键在与next数组，如何求得next数组，为什么这么求，为什么这么用next数组？

kmp算法的重要点在于它在模式串不匹配的时候不需要重新回退主串，只需要根据next数组调整模式串的起始匹配，接着匹配即可。

想一想这样一个主串：abcdeabc

以及这一个模式串：abce

一般算法是这样做的：

1. 主串索引0,模式串索引0

2. 同时逐个移动主串和模式串索引

3. 主串索引为3,模式串索引为3,'d' != 'e'，匹配失败

4. 回退主串索引到1,重置模式串索引为0, 执行2

5. 不断执行以上步骤


注意到第四步，有必要吗？当模式串索引重置到0的时候，

abcdeabc
 ^
abce
^

'b' != 'a' 然后又重置模式串索引，主串索引加1，

我们能否提前得知这种情况，然后排除这种情况，因为我们已经在第一次匹配成功了一部分abc,abce的首字母为a,和首字母为非a的匹配肯定不可能成功。

对了！

因此，我们可以记录这样一个next数组，他的作用是指示下一次尝试匹配从模式串的哪里开始，

比如上面的例子，主串为abcdeabc，那么模式串匹配失败，但是我们已经取得了“部分成功”，即abc是匹配的，利用这个消息我们就避免了a再和b和c的比较了。

因为这样的比较肯定是无效的：

abcdeabc
 ^
 abce 
 ^
 
abcdeabc
  ^
  abce 
  ^

我们可以直接让a和主串的d比较，这个比较是无法避免的，因为我们不知道主串下一个字符是什么，可能后面就是一个abce呢！

因此我们这样定义next数组：next[i] 表面模式串的位置为i的字符和主串的相应字符匹配失败后，下一个和主串当前位置匹配的模式串的字符的位置。

我们需要跳过尽可能多的“部分匹配”部分，需要注意，当我们制定模式串从某一个位置开始和主串匹配的时候，我们需要保证模式串这一位置之前的部分和

主串当前匹配位置之前相等长度的字符串是相同的，否则匹配就是失败的了。

举例子，abcabab和子串（就是模式串）abcabb

abcabab
   **^
abcabb
**^

画星号的部分必须相同，也就是部分匹配字符串的某个长度的前缀和后缀相同，那么我们就可以跳过模式串这个前缀或后缀的长度个字符，为了跳过最多的字符，我们

要找部分匹配字符串的最大相同前后缀的长度。

因此abcabb的next数组为0,0,0,1,2,0。

有一个地方需要注意，如果从主串某个字符开始匹配时，第一个字符双方就不相同，那么按照next数组，模式串还是会从第一个字符开始，主串索引不变的话就会不断重复，死循环。

因此我们要求，如果模式串根据next数组回退到第一个字符的时候，和主串不匹配，主串索引加1。也就是回退到一般算法。

* 求next数组

网上有一些求next数组的方法，但是我记得之前自己了解过一种类似递推的求next数组的方法，基本搞清楚了，用起来也觉得没问题。

模式串：abcabaab

基本思路就是，对于每一个位置上的字符，如果它前面位置的next数组值为0,也就是前面部分没有共同前后缀，那么如果它和第一个字符相等，next数组设为1,否则，设为0。

如果它前面位置的next数组值不为0,那就取他的值，比较next[i-1]位置上的字符和当前字符，如果相等，next数组就设为next[i-1]+1，否则，取next[next[i-1]-1]，

比较next[next[i-1]-1]位置上的字符和当前字符，如果相等，就设为，next[next[i-1]-1]+1，否则，继续取他的最大公共前后缀长度，然后继续比较。直到j=0,就比较第一个字符和当前字符，

如果相等，就设为0+1,否则就不再继续，设为0并退出。

0 1 2 3 4 5 6 7
a b c a b a a b
0 0 0 1 2 1 1 2

求位置5的next值：

abcaba
**^
   **^ 

next[5-1] = 2, s[2] != a, 取 next[2-1] = 0

abcaba
^    ^

s[0] == a , next[5] = 0 + 1 = 1

另一个示例:

0 1 2 3 4 5 6
a a a a a a b
0 1 2 3 4 5 0

求next[6]，

next[6-1] = 5

aaaaaab
*****^
 *****^ 

s[5] != b, 取next[5-1] = 4,

aaaaaab
****^
  ****^

s[4] != b, 取next[4-1] = 3;

...

s[1] != b, 取next[1-1] = 0;

aaaaaab
^
      ^

s[0] != b, 设next[6] = 0      

* 代码

** cpp

*** kmp

#+begin_src cpp
int kmp(string &s, string &ss){
  //假设next数组已知
  for(int i = 0, j = 0;i < s.length() && j < ss.length();){
     if(s[i] != ss[j]){
      j = j == 0 ? 0 : nxt[j-1];
      if(j == 0 && s[i] != ss[j]) i++;
    }else{
      if(j == ss.length()-1) return i-j;
      i++;
      j++;
    }
  }
  return -1;
}
#+end_src

*** 求next数组

#+begin_src cpp
void qnxt(string &p,vector<int> &nxt){
  int len = p.length();
  nxt[0] = 0;
  for(int i = 1;i < len;++i){
    if(nxt[i-1]==0)
      if(p[i] == p[0])
	nxt[i] = 1;
      else
	nxt[i] = 0;
    else{
      int j = nxt[i-1];
      while(j >= 0){
	if(p[j] == p[i]){
	  nxt[i] = j + 1;
	  break;
	}else{
	  if(j == 0){
	    nxt[i] = 0;
	    break;
	  }
	  j = nxt[j-1];
	}
      }
    }
  }
}

#+end_src
