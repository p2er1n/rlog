#+title: wp-wustctf2020-level1
#+author: Peerin
#+date: <2023-10-31 周二>

关键反汇编代码:

#+begin_src c
  for ( i = 1; i <= 19; ++i )
    {
      if ( (i & 1) != 0 )
	printf("%ld\n", (unsigned int)(ptr[i] << i));
      else
	printf("%ld\n", (unsigned int)(i * ptr[i]));
    }
#+end_src

题目还给出了输出的output文件。

对于1到19的每一个i，根据if条件决定走哪一条，然后按照相应的方式逆回去即可。

注意，对于位移分支，c语言中，在x86-64机器上，gcc编译出来的程序不论位移操作数的多么小(就算是char)，操作的临时结果也是32位的，

在底层执行的汇编代码是这个：

#+begin_src c
  shl eax, cl
#+end_src

使用的是32位的eax寄存器，因此在这个题目中，位移位数最多是19位，不会超出32位寄存器的界限，因此不需要考虑溢出。

对于乘法分支，最大的可能结果是19 * 127 也不会超过2**32-1(32位能存储的最大整数)，因此也不需要考虑溢出。

这样，逆向代码就很简单了：

#+begin_src python
  a = [198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000]

  for i in range(19):
      if ((i+1) & 1):
	  print(chr(a[i] >> (i+1)),end="")
      else:
	  print (chr(a[i] // (i+1)),end="")
#+end_src

* 知识点

x86-64机器上，gcc产生的64位程序的临时计算结果使用的最小寄存器也是32位的,不管高层c语言中操作数的变量类型的大小（当然如果变量更大，会选用64位寄存器）。

