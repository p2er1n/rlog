#+title: c语言中的整数表示和判断
#+author: Peerin
#+date: <Sun Oct 15 17:30:12 2023>

c 语言中的整数有很多类型，不同类型之间有的占据不同的存储空间，有的占据相同的存储空间，比如 char 和 unsigned char.

占据相同内存空间的不同类型之间的差别应该体现在对待内部存储的二进制位的不同上。

我们知道，负数在计算机内部的表示形式为补码（取反加1），而正数的补码表示是他本身（并不代表正数取反加1是他本身，只是对正数的补码编码为他本身的原码）。

我们还知道，c语言在读入整数字面量的时候（不管是何种读入形式，十六进制，十进制，二进制还是八进制），默认是int类型。

具体来说，c语言编译器看到整数字面量的时候，先转换成他的纯二进制位形式（10 -> 1010, 0x8 -> 1000）,对于负数，则转化成他的补码形式，然后再根据后缀或者强制类型转换或者隐性类型转换变化。

举例子，255

1. 是正数，则他的补码表示就是他的原码。
   
2. 没有后缀，默认为int（假如是4个字节）

3. 原码为0x0000ff

4. 假如赋值给signed char类型的变量，再进行强制类型转换（根据实现不同可能结果不同）

5. 解释的时候，把第一位当作符号位，0,也就是正数   

举例子， -1u

1. 是负数，则他的补码表示是他的正数原码的取反加1

2. 后缀为u,则为unsigned int（假定为4个字节）

3. 则补码为0xffffffff

4. 假如赋值给unsigned int,那么变量里面，存的就是0xffffffff

5. 解释的时候第一位不是符号位,因此表示数量的一共有32位

对于c语言中的相等运算符，进行比较的时候，比较的不是二进制位，而是对于这个类型，这些二进制位表示的数的大小是否相等。

因此，对于signed char类型的0xff 和 unsigned char类型的0xff,一个表示数量为-1,另一个表示数量为255,因此两个不相等，尽管他们的二进制表示完全相同。

#+begin_src c
  char sc = 255;
  //对于字面量255,为正数，存原码，默认为int,存32位，但是强转signed char（8位），因为最终存0xff
  unsigned char uc = 255;
  //对于字面量255,为正数，存原码，默认为int,存32位，但是强转unsigned char（8位），因为最终存0xff

  sc == 255;//false
  //sc为0xff,第一位为符号位，是1，即负数，因此解释1111111（7位）为负数的补码，也就是7位的-1,
  //而字面量255为正数，默认为int,二进制为0x000000ff,第一位为符号位，是0,即正数，因此解释0000...11111111为正数的原码，也就是31位的255,
  //因此他们两个不相等，-1不等于255

  sc == -1;//true
  //sc同理为7位的-1
  //-1同理为31位的-1
  //-1等于-1

  uc == 255;//true
  //uc为0xff,第一位不是符号位，因此解释为8位的255
  //字面量255默认为int,第一位是符号位，因此解释为31位的255
  //255等于255

  uc == -1;//false
  //uc同理解释为8位255
  //字面量-1为负数，因此补码为相应正数的原码取反加1,默认是int,因此内部表示为11111...1111(32位)，第一位为符号位，是1，即负数，因此解释为31位的-1
  //255不等于-1

  //但是下列都是true,因为比较之前都进行了强制类型转换，使得编译器缩减了二进制位，并且进行了不同的解释。
  sc == (signed char)255;
  //先将111...111(32位)缩减为8位，然后将第一位解释为符号位，所以解释为7位的-1

  uc == (unsigned char)-1;
  //先将111...111(32位)缩减为8位，然后不将第一位解释为符号位，所以解释为8位的255
#+end_src
